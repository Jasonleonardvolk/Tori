{
  "version": 3,
  "sources": ["../../@langchain/langgraph-sdk/dist/react/stream.js"],
  "sourcesContent": ["/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\"use client\";\nimport { Client } from \"../client.js\";\nimport { useCallback, useEffect, useMemo, useRef, useState, } from \"react\";\nimport { coerceMessageLikeToMessage, convertToChunk, isBaseMessageChunk, } from \"@langchain/core/messages\";\nclass StreamError extends Error {\n    constructor(data) {\n        super(data.message);\n        this.name = data.name ?? data.error ?? \"StreamError\";\n    }\n    static isStructuredError(error) {\n        return typeof error === \"object\" && error != null && \"message\" in error;\n    }\n}\nfunction tryConvertToChunk(message) {\n    try {\n        return convertToChunk(message);\n    }\n    catch {\n        return null;\n    }\n}\nclass MessageTupleManager {\n    constructor() {\n        Object.defineProperty(this, \"chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        this.chunks = {};\n    }\n    add(serialized) {\n        // TODO: this is sometimes sent from the API\n        // figure out how to prevent this or move this to LC.js\n        if (serialized.type.endsWith(\"MessageChunk\")) {\n            serialized.type = serialized.type\n                .slice(0, -\"MessageChunk\".length)\n                .toLowerCase();\n        }\n        const message = coerceMessageLikeToMessage(serialized);\n        const chunk = tryConvertToChunk(message);\n        const id = (chunk ?? message).id;\n        if (!id) {\n            console.warn(\"No message ID found for chunk, ignoring in state\", serialized);\n            return null;\n        }\n        this.chunks[id] ??= {};\n        if (chunk) {\n            const prev = this.chunks[id].chunk;\n            this.chunks[id].chunk =\n                (isBaseMessageChunk(prev) ? prev : null)?.concat(chunk) ?? chunk;\n        }\n        else {\n            this.chunks[id].chunk = message;\n        }\n        return id;\n    }\n    clear() {\n        this.chunks = {};\n    }\n    get(id, defaultIndex) {\n        if (this.chunks[id] == null)\n            return null;\n        this.chunks[id].index ??= defaultIndex;\n        return this.chunks[id];\n    }\n}\nconst toMessageDict = (chunk) => {\n    const { type, data } = chunk.toDict();\n    return { ...data, type };\n};\nfunction unique(array) {\n    return [...new Set(array)];\n}\nfunction findLastIndex(array, predicate) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        if (predicate(array[i]))\n            return i;\n    }\n    return -1;\n}\nfunction getBranchSequence(history) {\n    const childrenMap = {};\n    // First pass - collect nodes for each checkpoint\n    history.forEach((state) => {\n        const checkpointId = state.parent_checkpoint?.checkpoint_id ?? \"$\";\n        childrenMap[checkpointId] ??= [];\n        childrenMap[checkpointId].push(state);\n    });\n    const rootSequence = { type: \"sequence\", items: [] };\n    const queue = [{ id: \"$\", sequence: rootSequence, path: [] }];\n    const paths = [];\n    const visited = new Set();\n    while (queue.length > 0) {\n        const task = queue.shift();\n        if (visited.has(task.id))\n            continue;\n        visited.add(task.id);\n        const children = childrenMap[task.id];\n        if (children == null || children.length === 0)\n            continue;\n        // If we've encountered a fork (2+ children), push the fork\n        // to the sequence and add a new sequence for each child\n        let fork;\n        if (children.length > 1) {\n            fork = { type: \"fork\", items: [] };\n            task.sequence.items.push(fork);\n        }\n        for (const value of children) {\n            const id = value.checkpoint.checkpoint_id;\n            let sequence = task.sequence;\n            let path = task.path;\n            if (fork != null) {\n                sequence = { type: \"sequence\", items: [] };\n                fork.items.unshift(sequence);\n                path = path.slice();\n                path.push(id);\n                paths.push(path);\n            }\n            sequence.items.push({ type: \"node\", value, path });\n            queue.push({ id, sequence, path });\n        }\n    }\n    return { rootSequence, paths };\n}\nconst PATH_SEP = \">\";\nconst ROOT_ID = \"$\";\n// Get flat view\nfunction getBranchView(sequence, paths, branch) {\n    const path = branch.split(PATH_SEP);\n    const pathMap = {};\n    for (const path of paths) {\n        const parent = path.at(-2) ?? ROOT_ID;\n        pathMap[parent] ??= [];\n        pathMap[parent].unshift(path);\n    }\n    const history = [];\n    const branchByCheckpoint = {};\n    const forkStack = path.slice();\n    const queue = [...sequence.items];\n    while (queue.length > 0) {\n        const item = queue.shift();\n        if (item.type === \"node\") {\n            history.push(item.value);\n            branchByCheckpoint[item.value.checkpoint.checkpoint_id] = {\n                branch: item.path.join(PATH_SEP),\n                branchOptions: (item.path.length > 0\n                    ? pathMap[item.path.at(-2) ?? ROOT_ID] ?? []\n                    : []).map((p) => p.join(PATH_SEP)),\n            };\n        }\n        if (item.type === \"fork\") {\n            const forkId = forkStack.shift();\n            const index = forkId != null\n                ? item.items.findIndex((value) => {\n                    const firstItem = value.items.at(0);\n                    if (!firstItem || firstItem.type !== \"node\")\n                        return false;\n                    return firstItem.value.checkpoint.checkpoint_id === forkId;\n                })\n                : -1;\n            const nextItems = item.items.at(index)?.items ?? [];\n            queue.push(...nextItems);\n        }\n    }\n    return { history, branchByCheckpoint };\n}\nfunction fetchHistory(client, threadId) {\n    return client.threads.getHistory(threadId, { limit: 1000 });\n}\nfunction useThreadHistory(threadId, client, clearCallbackRef, submittingRef) {\n    const [history, setHistory] = useState([]);\n    const fetcher = useCallback((threadId) => {\n        if (threadId != null) {\n            return fetchHistory(client, threadId).then((history) => {\n                setHistory(history);\n                return history;\n            });\n        }\n        setHistory([]);\n        clearCallbackRef.current?.();\n        return Promise.resolve([]);\n    }, []);\n    useEffect(() => {\n        if (submittingRef.current)\n            return;\n        fetcher(threadId);\n    }, [fetcher, submittingRef, threadId]);\n    return {\n        data: history,\n        mutate: (mutateId) => fetcher(mutateId ?? threadId),\n    };\n}\nconst useControllableThreadId = (options) => {\n    const [localThreadId, _setLocalThreadId] = useState(options?.threadId ?? null);\n    const onThreadIdRef = useRef(options?.onThreadId);\n    onThreadIdRef.current = options?.onThreadId;\n    const onThreadId = useCallback((threadId) => {\n        _setLocalThreadId(threadId);\n        onThreadIdRef.current?.(threadId);\n    }, []);\n    if (!options || !(\"threadId\" in options)) {\n        return [localThreadId, onThreadId];\n    }\n    return [options.threadId ?? null, onThreadId];\n};\nexport function useStream(options) {\n    let { assistantId, messagesKey, onError, onFinish } = options;\n    messagesKey ??= \"messages\";\n    const client = useMemo(() => new Client({\n        apiUrl: options.apiUrl,\n        apiKey: options.apiKey,\n        callerOptions: options.callerOptions,\n        defaultHeaders: options.defaultHeaders,\n    }), [\n        options.apiKey,\n        options.apiUrl,\n        options.callerOptions,\n        options.defaultHeaders,\n    ]);\n    const [threadId, onThreadId] = useControllableThreadId(options);\n    const [branch, setBranch] = useState(\"\");\n    const [isLoading, setIsLoading] = useState(false);\n    const [streamError, setStreamError] = useState(undefined);\n    const [streamValues, setStreamValues] = useState(null);\n    const messageManagerRef = useRef(new MessageTupleManager());\n    const submittingRef = useRef(false);\n    const abortRef = useRef(null);\n    const trackStreamModeRef = useRef([]);\n    const trackStreamMode = useCallback((...mode) => {\n        for (const m of mode) {\n            if (!trackStreamModeRef.current.includes(m)) {\n                trackStreamModeRef.current.push(m);\n            }\n        }\n    }, []);\n    const hasUpdateListener = options.onUpdateEvent != null;\n    const hasCustomListener = options.onCustomEvent != null;\n    const callbackStreamMode = useMemo(() => {\n        const modes = [];\n        if (hasUpdateListener)\n            modes.push(\"updates\");\n        if (hasCustomListener)\n            modes.push(\"custom\");\n        return modes;\n    }, [hasUpdateListener, hasCustomListener]);\n    const clearCallbackRef = useRef(null);\n    clearCallbackRef.current = () => {\n        setStreamError(undefined);\n        setStreamValues(null);\n    };\n    // TODO: this should be done on the server to avoid pagination\n    // TODO: should we permit adapter? SWR / React Query?\n    const history = useThreadHistory(threadId, client, clearCallbackRef, submittingRef);\n    const getMessages = useMemo(() => {\n        return (value) => Array.isArray(value[messagesKey])\n            ? value[messagesKey]\n            : [];\n    }, [messagesKey]);\n    const { rootSequence, paths } = getBranchSequence(history.data);\n    const { history: flatHistory, branchByCheckpoint } = getBranchView(rootSequence, paths, branch);\n    const threadHead = flatHistory.at(-1);\n    const historyValues = threadHead?.values ?? {};\n    const historyError = (() => {\n        const error = threadHead?.tasks?.at(-1)?.error;\n        if (error == null)\n            return undefined;\n        try {\n            const parsed = JSON.parse(error);\n            if (StreamError.isStructuredError(parsed)) {\n                return new StreamError(parsed);\n            }\n            return parsed;\n        }\n        catch {\n            // do nothing\n        }\n        return error;\n    })();\n    const messageMetadata = (() => {\n        const alreadyShown = new Set();\n        return getMessages(historyValues).map((message, idx) => {\n            const messageId = message.id ?? idx;\n            const firstSeenIdx = findLastIndex(history.data, (state) => getMessages(state.values)\n                .map((m, idx) => m.id ?? idx)\n                .includes(messageId));\n            const firstSeen = history.data[firstSeenIdx];\n            let branch = firstSeen\n                ? branchByCheckpoint[firstSeen.checkpoint.checkpoint_id]\n                : undefined;\n            if (!branch?.branch?.length)\n                branch = undefined;\n            // serialize branches\n            const optionsShown = branch?.branchOptions?.flat(2).join(\",\");\n            if (optionsShown) {\n                if (alreadyShown.has(optionsShown))\n                    branch = undefined;\n                alreadyShown.add(optionsShown);\n            }\n            return {\n                messageId: messageId.toString(),\n                firstSeenState: firstSeen,\n                branch: branch?.branch,\n                branchOptions: branch?.branchOptions,\n            };\n        });\n    })();\n    const stop = useCallback(() => {\n        if (abortRef.current != null)\n            abortRef.current.abort();\n        abortRef.current = null;\n    }, []);\n    const submit = async (values, submitOptions) => {\n        try {\n            setIsLoading(true);\n            setStreamError(undefined);\n            submittingRef.current = true;\n            abortRef.current = new AbortController();\n            let usableThreadId = threadId;\n            if (!usableThreadId) {\n                const thread = await client.threads.create();\n                onThreadId(thread.thread_id);\n                usableThreadId = thread.thread_id;\n            }\n            const streamMode = unique([\n                ...(submitOptions?.streamMode ?? []),\n                ...trackStreamModeRef.current,\n                ...callbackStreamMode,\n            ]);\n            const checkpoint = submitOptions?.checkpoint ?? threadHead?.checkpoint ?? undefined;\n            // @ts-expect-error\n            if (checkpoint != null)\n                delete checkpoint.thread_id;\n            const run = (await client.runs.stream(usableThreadId, assistantId, {\n                input: values,\n                config: submitOptions?.config,\n                command: submitOptions?.command,\n                interruptBefore: submitOptions?.interruptBefore,\n                interruptAfter: submitOptions?.interruptAfter,\n                metadata: submitOptions?.metadata,\n                multitaskStrategy: submitOptions?.multitaskStrategy,\n                onCompletion: submitOptions?.onCompletion,\n                onDisconnect: submitOptions?.onDisconnect ?? \"cancel\",\n                signal: abortRef.current.signal,\n                checkpoint,\n                streamMode,\n            }));\n            // Unbranch things\n            const newPath = submitOptions?.checkpoint?.checkpoint_id\n                ? branchByCheckpoint[submitOptions?.checkpoint?.checkpoint_id]?.branch\n                : undefined;\n            if (newPath != null)\n                setBranch(newPath ?? \"\");\n            // Assumption: we're setting the initial value\n            // Used for instant feedback\n            setStreamValues(() => {\n                const values = { ...historyValues };\n                if (submitOptions?.optimisticValues != null) {\n                    return {\n                        ...values,\n                        ...(typeof submitOptions.optimisticValues === \"function\"\n                            ? submitOptions.optimisticValues(values)\n                            : submitOptions.optimisticValues),\n                    };\n                }\n                return values;\n            });\n            let streamError;\n            for await (const { event, data } of run) {\n                if (event === \"error\") {\n                    streamError = new StreamError(data);\n                    break;\n                }\n                if (event === \"updates\")\n                    options.onUpdateEvent?.(data);\n                if (event === \"custom\")\n                    options.onCustomEvent?.(data, {\n                        mutate: (update) => setStreamValues((prev) => {\n                            // should not happen\n                            if (prev == null)\n                                return prev;\n                            return {\n                                ...prev,\n                                ...(typeof update === \"function\" ? update(prev) : update),\n                            };\n                        }),\n                    });\n                if (event === \"metadata\")\n                    options.onMetadataEvent?.(data);\n                if (event === \"values\")\n                    setStreamValues(data);\n                if (event === \"messages\") {\n                    const [serialized] = data;\n                    const messageId = messageManagerRef.current.add(serialized);\n                    if (!messageId) {\n                        console.warn(\"Failed to add message to manager, no message ID found\");\n                        continue;\n                    }\n                    setStreamValues((streamValues) => {\n                        const values = { ...historyValues, ...streamValues };\n                        // Assumption: we're concatenating the message\n                        const messages = getMessages(values).slice();\n                        const { chunk, index } = messageManagerRef.current.get(messageId, messages.length) ?? {};\n                        if (!chunk || index == null)\n                            return values;\n                        messages[index] = toMessageDict(chunk);\n                        return { ...values, [messagesKey]: messages };\n                    });\n                }\n            }\n            // TODO: stream created checkpoints to avoid an unnecessary network request\n            const result = await history.mutate(usableThreadId);\n            setStreamValues(null);\n            if (streamError != null)\n                throw streamError;\n            const lastHead = result.at(0);\n            if (lastHead)\n                onFinish?.(lastHead);\n        }\n        catch (error) {\n            if (!(error instanceof Error &&\n                (error.name === \"AbortError\" || error.name === \"TimeoutError\"))) {\n                console.error(error);\n                setStreamError(error);\n                onError?.(error);\n            }\n        }\n        finally {\n            setIsLoading(false);\n            // Assumption: messages are already handled, we can clear the manager\n            messageManagerRef.current.clear();\n            submittingRef.current = false;\n            abortRef.current = null;\n        }\n    };\n    const error = streamError ?? historyError;\n    const values = streamValues ?? historyValues;\n    return {\n        get values() {\n            trackStreamMode(\"values\");\n            return values;\n        },\n        client,\n        assistantId,\n        error,\n        isLoading,\n        stop,\n        submit,\n        branch,\n        setBranch,\n        history: flatHistory,\n        experimental_branchTree: rootSequence,\n        get interrupt() {\n            // Don't show the interrupt if the stream is loading\n            if (isLoading)\n                return undefined;\n            const interrupts = threadHead?.tasks?.at(-1)?.interrupts;\n            if (interrupts == null || interrupts.length === 0) {\n                // check if there's a next task present\n                const next = threadHead?.next ?? [];\n                if (!next.length || error != null)\n                    return undefined;\n                return { when: \"breakpoint\" };\n            }\n            // Return only the current interrupt\n            return interrupts.at(-1);\n        },\n        get messages() {\n            trackStreamMode(\"messages-tuple\", \"values\");\n            return getMessages(values);\n        },\n        getMessagesMetadata(message, index) {\n            trackStreamMode(\"messages-tuple\", \"values\");\n            return messageMetadata?.find((m) => m.messageId === (message.id ?? index));\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["path", "threadId", "history", "error", "idx", "branch", "values", "streamError", "streamValues"]
}
