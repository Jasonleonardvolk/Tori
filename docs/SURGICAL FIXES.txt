🔧 SURGICAL FIXES:
1. Enhanced FastAPI Logging:
W
write_file
Request
{
"path": "C:\Users\jason\Desktop\tori\kha\ingest_pdf\main.py",
"content": "from fastapi import FastAPI, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom ingest_pdf.pipeline import ingest_pdf_clean\nimport tempfile\nimport os\nimport logging\n\napp = FastAPI()\n\n# CORS: Allow frontend (Vite/SvelteKit) to connect\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[""],\n    allow_credentials=True,\n    allow_methods=[""],\n    allow_headers=["*"],\n)\n\n# Logging setup\nlogging.basicConfig(level=logging.INFO)\n\n@app.post("/extract")\nasync def extract(file: UploadFile = File(...)):\n    try:\n        print(f"📥 [FASTAPI] Received upload: {file.filename}")\n        print(f"📋 [FASTAPI] Content type: {file.content_type}")\n        print(f"📏 [FASTAPI] File size: {file.size if hasattr(file, 'size') else 'unknown'}")\n        \n        print("📦 [FASTAPI] Reading file content...")\n        content = await file.read()\n        print(f"📦 [FASTAPI] Read {len(content)} bytes successfully")\n        \n        print("💾 [FASTAPI] Creating temp file...")\n        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:\n            tmp.write(content)\n            tmp.flush()\n            tmp_path = tmp.name\n            print(f"💾 [FASTAPI] Temp file created: {tmp_path}")\n\n        print(f"🚀 [FASTAPI] Starting pipeline processing...")\n        result = ingest_pdf_clean(tmp_path)\n        print(f"✅ [FASTAPI] Pipeline completed successfully")\n        \n        os.remove(tmp_path)\n        print(f"🗑️ [FASTAPI] Temp file cleaned up")\n\n        concept_count = result.get('concept_count', 0)\n        print(f"📊 [FASTAPI] Extracted {concept_count} concepts")\n        print(f"🎯 [FASTAPI] Returning result to frontend")\n        \n        return result\n\n    except Exception as e:\n        print(f"❌ [FASTAPI] ERROR during extraction: {type(e).name}: {e}")\n        import traceback\n        print(f"🔍 [FASTAPI] Full traceback:")\n        traceback.print_exc()\n        \n        return {\n            "success": False,\n            "error": str(e),\n            "error_type": type(e).name,\n            "concept_count": 0,\n            "concept_names": [],\n            "status": "error"\n        }"
}
Response
Successfully wrote to C:\Users\jason\Desktop\tori\kha\ingest_pdf\main.py
2. Enhanced SvelteKit Logging:
W
write_file
Request
{
"path": "C:\Users\jason\Desktop\tori\kha\tori_ui_svelte\src\routes\upload\+server.ts",
"content": "// +server.ts — ENHANCED DEBUGGING: CONNECTION RESET DIAGNOSIS\nimport { error, json } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { writeFile, mkdir } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\n\n// TypeScript fallback concept extractor\nfunction extractConcepts(text: string, filename: string): string[] {\n  const concepts: string[] = [];\n  const lowerText = text.toLowerCase();\n  const lowerFilename = filename.toLowerCase();\n\n  if (filename.endsWith('.pdf')) concepts.push('PDF Document');\n  if (lowerText.includes('abstract') || lowerText.includes('introduction') || lowerText.includes('methodology')) concepts.push('Academic Paper');\n  if (lowerText.includes('research') || lowerText.includes('study') || lowerText.includes('analysis')) concepts.push('Research');\n  if (lowerText.includes('conclusion') || lowerText.includes('results') || lowerText.includes('findings')) concepts.push('Study Results');\n  if (lowerText.includes('algorithm') || lowerText.includes('method') || lowerText.includes('approach')) concepts.push('Technical Method');\n  if (lowerText.includes('ai') || lowerText.includes('artificial intelligence') || lowerText.includes('machine learning')) concepts.push('Artificial Intelligence');\n  if (lowerText.includes('neural') || lowerText.includes('network') || lowerText.includes('deep learning')) concepts.push('Neural Networks');\n  if (lowerText.includes('cognitive') || lowerText.includes('consciousness') || lowerText.includes('memory')) concepts.push('Cognitive Science');\n  if (lowerText.includes('philosophy') || lowerText.includes('ethics') || lowerText.includes('theory')) concepts.push('Philosophy');\n  if (lowerText.includes('data') || lowerText.includes('dataset') || lowerText.includes('statistics')) concepts.push('Data Science');\n  if (lowerText.includes('quantum') || lowerText.includes('physics') || lowerText.includes('particle')) concepts.push('Physics');\n  if (lowerText.includes('biology') || lowerText.includes('genetic') || lowerText.includes('evolution')) concepts.push('Biology');\n  if (lowerText.includes('mathematics') || lowerText.includes('theorem') || lowerText.includes('proof')) concepts.push('Mathematics');\n  if (lowerText.includes('computer') || lowerText.includes('software') || lowerText.includes('programming')) concepts.push('Computer Science');\n  if (lowerText.includes('learning') || lowerText.includes('education') || lowerText.includes('training')) concepts.push('Learning');\n  if (lowerFilename.includes('report')) concepts.push('Report');\n  if (lowerFilename.includes('manual') || lowerFilename.includes('guide')) concepts.push('Documentation');\n  if (lowerFilename.includes('spec') || lowerFilename.includes('requirement')) concepts.push('Specification');\n\n  concepts.push('ScholarSphere Document');\n  return [...new Set(concepts)];\n}\n\n// ELFIN++ Trigger - Server-side compatible\nfunction triggerELFINUpload(filename: string, text: string, concepts: string[]) {\n  try {\n    console.log('🧬 [ELFIN++] onUpload triggered:', {\n      filename,\n      conceptCount: concepts.length,\n      preview: text.substring(0, 100) + '...',\n      timestamp: new Date().toISOString(),\n      source: 'scholarsphere'\n    });\n    \n    // Log for any listening services\n    console.log('🧬 [ELFIN++] Event Data:', JSON.stringify({\n      type: 'tori:upload',\n      filename,\n      concepts,\n      textPreview: text.substring(0, 500),\n      timestamp: new Date().toISOString(),\n      source: 'scholarsphere'\n    }));\n    \n    return true;\n  } catch (err) {\n    console.warn('🧬 [ELFIN++] hook failed:', err);\n    return false;\n  }\n}\n\nexport const POST: RequestHandler = async ({ request, locals }) => {\n  console.log('📥 [UPLOAD] Processing upload request...');\n  \n  // 🛡️ Security check\n  if (!locals.user || locals.user.role !== 'admin') {\n    console.log('❌ [UPLOAD] Access denied - admin role required');\n    throw error(403, 'Admin access required for document uploads');\n  }\n  \n  console.log(👤 [UPLOAD] User authorized: ${locals.user.name});\n\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n\n    if (!file) {\n      console.log('❌ [UPLOAD] No file in request');\n      throw error(400, 'No file uploaded');\n    }\n\n    console.log(📁 [UPLOAD] File received: ${file.name} (${file.size} bytes, ${file.type}));\n\n    // 🛡️ Validation\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      console.log(❌ [UPLOAD] File too large: ${file.size} bytes);\n      throw error(400, 'File too large (max 50MB)');\n    }\n\n    const allowedTypes = ['application/pdf', 'text/plain', 'application/json'];\n    if (!allowedTypes.includes(file.type) && !file.name.toLowerCase().endsWith('.pdf')) {\n      console.log(❌ [UPLOAD] Invalid file type: ${file.type});\n      throw error(400, 'Unsupported file type. PDF, TXT, and JSON files only.');\n    }\n\n    // 🛡️ Sanitize filename\n    const sanitizedFilename = file.name.replace(/[^a-zA-Z0-9.-]/g, '_').substring(0, 100);\n    const timestamp = Date.now();\n    const uniqueFilename = ${timestamp}_${sanitizedFilename};\n\n    console.log(📋 [UPLOAD] Sanitized filename: ${uniqueFilename});\n\n    // 💾 Save file to disk\n    const uploadDir = join(process.cwd(), 'data', 'sphere', 'admin');\n    if (!existsSync(uploadDir)) {\n      console.log(📁 [UPLOAD] Creating upload directory: ${uploadDir});\n      await mkdir(uploadDir, { recursive: true });\n    }\n\n    const filePath = join(uploadDir, uniqueFilename);\n    const arrayBuffer = await file.arrayBuffer();\n    await writeFile(filePath, new Uint8Array(arrayBuffer));\n\n    console.log(💾 [UPLOAD] File saved: ${filePath});\n\n    // ========== STEP 1: Try Python API for extraction ==========\n    console.log('🚀 [UPLOAD] STEP 1: Attempting Python API extraction...');\n    const proxyFormData = new FormData();\n    proxyFormData.append('file', file); // ✅ Matches FastAPI parameter name\n\n    let conceptNames: string[] = [];\n    let apiUsed = false;\n    let method = 'typescript_fallback';\n    let extractedText = '';\n    let pythonResult: any = null;\n    let processingTime = 0;\n\n    try {\n      const startTime = Date.now();\n      \n      // 🔧 ENHANCED DEBUGGING: Monitor connection closely\n      console.log('🚀 [UPLOAD] Sending file to FastAPI:', file.name, (${file.size} bytes));\n      console.log('🔗 [UPLOAD] Target URL: http://localhost:8002/extract');\n      console.log('📋 [UPLOAD] FormData key: "file" (matches FastAPI parameter)');\n      \n      const res = await fetch('http://localhost:8002/extract', {\n        method: 'POST',\n        body: proxyFormData,\n        signal: AbortSignal.timeout(45000) // 45 second timeout\n      });\n\n      processingTime = (Date.now() - startTime) / 1000;\n      console.log(📊 [UPLOAD] Python API responded in ${processingTime}s with status: ${res.status});\n\n      if (res.ok) {\n        console.log('📦 [UPLOAD] Reading JSON response...');\n        pythonResult = await res.json();\n        console.log('📦 [UPLOAD] JSON response received successfully');\n        \n        conceptNames = pythonResult.concept_names || [];\n        method = pythonResult.extraction_method || 'universal_pipeline';\n        apiUsed = true;\n        \n        console.log('✅ [UPLOAD] Python API SUCCESS:', {\n          conceptCount: conceptNames.length,\n          method: method,\n          processingTime: processingTime\n        });\n        \n        console.log('📊 [UPLOAD] Extracted concepts:', conceptNames.slice(0, 10));\n      } else {\n        console.error(❌ [UPLOAD] Python API HTTP error: ${res.status} ${res.statusText});\n        const errorText = await res.text().catch(e => Failed to read error: ${e});\n        console.error(❌ [UPLOAD] Error response body:, errorText);\n        throw new Error(HTTP ${res.status}: ${errorText});\n      }\n    } catch (err: any) {\n      console.error('❌ [UPLOAD] Fetch to Python API failed:', {\n        name: err.name,\n        message: err.message,\n        cause: err.cause,\n        stack: err.stack?.split('\n').slice(0, 3).join('\n')\n      });\n      \n      // Enhanced error categorization\n      if (err.name === 'TimeoutError' || err.message.includes('timeout')) {\n        console.error('⏰ [UPLOAD] TIMEOUT: Python API took longer than 45 seconds');\n      } else if (err.message.includes('ECONNREFUSED')) {\n        console.error('🚫 [UPLOAD] CONNECTION REFUSED: Python server not running or not accepting connections');\n      } else if (err.message.includes('ENOTFOUND')) {\n        console.error('🌐 [UPLOAD] HOST NOT FOUND: Cannot resolve localhost:8002');\n      } else if (err.message.includes('ECONNRESET') || err.message.includes('10054')) {\n        console.error('🔌 [UPLOAD] CONNECTION RESET: Remote host forcibly closed connection');\n        console.error('🔍 [UPLOAD] This usually means FastAPI crashed during processing');\n      } else if (err.name === 'AbortError') {\n        console.error('🛑 [UPLOAD] REQUEST ABORTED: Fetch was cancelled');\n      } else {\n        console.error('🤔 [UPLOAD] UNKNOWN NETWORK ERROR - investigate further');\n      }\n    }\n\n    // ========== STEP 2: Fallback TypeScript Extraction ==========\n    if (!apiUsed || conceptNames.length === 0) {\n      console.log('🔄 [UPLOAD] STEP 2: Using TypeScript fallback extraction...');\n      extractedText = new TextDecoder('utf-8', { fatal: false }).decode(arrayBuffer);\n      conceptNames = extractConcepts(extractedText, file.name);\n      method = 'typescript_fallback';\n      \n      console.log(✅ [UPLOAD] TypeScript fallback complete: ${conceptNames.length} concepts);\n      console.log('📊 [UPLOAD] Fallback concepts:', conceptNames);\n    }\n\n    // 🧬 Convert concept names to full concept objects\n    const concepts = conceptNames.map((name, index) => ({\n      name,\n      score: Math.max(0.4, 0.95 - index * 0.03), // Descending scores from 0.95 to 0.4\n      method,\n      source: {\n        python_extraction: apiUsed,\n        fallback_used: !apiUsed,\n        rank: index + 1\n      },\n      context: apiUsed ? Python-extracted concept: ${name} : Fallback-extracted concept: ${name},\n      metadata: {\n        extraction_method: method,\n        processing_time: processingTime,\n        file_type: file.type,\n        file_size: file.size\n      }\n    }));\n\n    console.log(🧬 [UPLOAD] Created ${concepts.length} concept objects);\n\n    // 🧬 Trigger ELFIN++ processing\n    const elfinTriggered = triggerELFINUpload(file.name, extractedText || '[Binary file - text not extracted]', conceptNames);\n\n    // 📊 Prepare comprehensive response\n    const documentData = {\n      id: doc_${timestamp},\n      filename: file.name,\n      uniqueFilename,\n      size: file.size,\n      type: file.type,\n      concepts: concepts,\n      uploadedAt: new Date().toISOString(),\n      uploadedBy: locals.user.name,\n      filePath,\n      elfinTriggered,\n      summary: Extraction found ${concepts.length} concepts using ${method},\n      extractionMethod: method,\n      conceptCount: concepts.length,\n      pythonApiUsed: apiUsed,\n      processingTime: processingTime\n    };\n\n    console.log('📚 [UPLOAD] UPLOAD COMPLETE:', {\n      filename: file.name,\n      size: file.size,\n      concepts: concepts.length,\n      method: method,\n      apiUsed: apiUsed,\n      processingTime: processingTime,\n      elfinTriggered: elfinTriggered\n    });\n\n    // 🎯 Return complete response\n    return json({\n      success: true,\n      message: Document uploaded and processed successfully (${method}),\n      filename: file.name,\n      size: file.size,\n      concepts: concepts, // Full concept objects array\n      conceptCount: concepts.length,\n      extractionMethod: method,\n      apiUsed: apiUsed,\n      elfinTriggered: elfinTriggered,\n      processingTime: processingTime,\n      document: documentData, // Complete document object for frontend\n      pythonResult: pythonResult // Include raw Python result for debugging\n    });\n\n  } catch (err) {\n    console.error('💥 [UPLOAD] Upload processing failed:', err);\n    \n    if (err instanceof Error && err.message.includes('Admin access required')) {\n      throw err;\n    }\n    \n    throw error(500, 'Upload processing failed: ' + (err instanceof Error ? err.message : 'Unknown error'));\n  }\n};"
}
Response
Successfully wrote to C:\Users\jason\Desktop\tori\kha\tori_ui_svelte\src\routes\upload+server.ts
🔧 3. Restart Python Server with Enhanced Logging: