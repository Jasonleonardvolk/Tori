# ALAN IDE Phase 3 - Sprint 2 Implementation

This document outlines the implementation of the Sprint 2 components for the ALAN IDE Phase 3, as specified in the roadmap. The focus for Sprint 2 is on bidirectional synchronization, persona system, and accessibility framework.

## 1. Bidirectional Editor â†” Concept-Graph Sync

The bidirectional synchronization system connects the text-based code editor with the visual concept graph, enabling real-time updates in both directions.

### Key Components

- **Editor Sync Service (`client/src/services/editorSyncService.js`)**:
  - Manages bidirectional synchronization between CodeMirror and the ConceptFieldCanvas
  - Handles editor events (changes, selections, viewport) and propagates to concept view
  - Maps between editor positions and concept nodes with an efficient position map
  - Implements throttled and debounced event handling for performance
  - Provides utilities for highlighting, gutters, and markers

- **Performance Utilities (`client/src/utils/performance.js`)**:
  - Provides debounce and throttle functions for efficient event handling
  - Includes memoization for caching function results
  - Implements afterNextPaint for performant visual updates
  - Provides measurement tools for performance monitoring

- **Concept Editor Panel (`client/src/components/ConceptEditorPanel/`)**:
  - Integrates CodeMirror editor with ConceptFieldCanvas
  - Manages multiple layout options (horizontal split, vertical split, concept-first)
  - Adapts to different personas with appropriate configuration
  - Implements keyboard shortcuts (Alt+C to toggle, Alt+L to cycle layouts)
  - Provides toolbar for visual control

### How It Works

1. The `ConceptEditorPanel` initializes both the CodeMirror editor and ConceptFieldCanvas
2. `editorSyncService` connects to both components and sets up event listeners
3. When text is edited in CodeMirror, changes are parsed and mapped to concept nodes
4. When nodes are selected in the concept graph, corresponding text is highlighted in the editor
5. Position mapping maintains the relationship between code positions and concept nodes
6. Layout can be adjusted based on user preference or active persona

## 2. Persona System & Accessibility

The persona system allows the IDE to adapt to different user workflows, while the accessibility framework ensures universal access for both humans and agents.

### Key Components

- **Persona Context (`client/src/components/PersonaSelector/PersonaContext.js`)**:
  - Defines the four required personas with their features and preferences:
    - Power Coder: Traditional IDE experience focused on efficiency
    - Concept Architect: Systems-thinking view with concept relationships
    - Design-First Maker: UI/UX focused experience with visual tools
    - Ops/DevTools Engineer: Security and pipeline focused
  - Manages persona switching with React Context
  - Implements the "panic switch" (Alt+P) to quickly return to Power Coder view
  - Generates appropriate layouts for each persona
  - Stores user preference in localStorage for persistence

- **Persona Selector (`client/src/components/PersonaSelector/PersonaSelector.jsx`)**:
  - Provides UI for switching between personas
  - Includes detailed descriptions of each persona
  - Indicates currently active persona
  - Implements ARIA attributes for accessibility
  - Responds to keyboard interactions

- **Accessibility Bridge (`client/src/services/accessibilityBridgeService.js`)**:
  - Creates a bridge between the UI and automated agents
  - Generates a tree representation of the IDE's UI components
  - Implements a command registry and execution system
  - Provides WebSocket communication for external agent integration
  - Scans the DOM for accessibility nodes and attributes
  - Supports keyboard navigation and screen readers

### How It Works

1. `PersonaProvider` wraps the application and provides context for the current persona
2. `PersonaSelector` allows users to switch between personas via UI
3. Components adapt to the active persona using the `usePersona` hook
4. Alt+P serves as the "panic switch" to immediately return to Power Coder view
5. `accessibilityBridgeService` scans the UI and builds a comprehensive tree
6. UI components register with the bridge to expose their functionality
7. External agents can connect via WebSocket and operate the IDE through commands

## Integration Points

The Sprint 2 components integrate with the existing Sprint 1 foundation:

1. **Concept Graph Integration**:
   - The `editorSyncService` connects to the concept graph generated by the Python AST importer
   - ConceptFieldCanvas visualizes the concept graph with phase dynamics
   - Bidirectional sync ensures consistency between code and graph

2. **Vault Integration**:
   - The Ops Engineer persona has direct access to the Vault Manager
   - Security scanning from Sprint 1 is surfaced in the Ops Engineer view

3. **Accessibility & Agent Integration**:
   - The accessibility bridge provides access to all IDE components
   - Agent commands can operate the concept graph and editor
   - The bridge follows the MCP protocol for interoperability

## Next Steps for Sprint 3

1. **Execution Field Tracer**:
   - Connect Field Meditation Mode to Python execution
   - Implement phase-state events during runtime
   - Add divergence detection for warnings

2. **Agent Bridge Enhancements**:
   - Complete the UI command API
   - Implement multi-agent communication
   - Support more complex agent workflows

## Usage Examples

### Switching Personas

```jsx
// Inside a component
import { usePersona } from '../components/PersonaSelector/PersonaContext';

function MyComponent() {
  const { currentPersona, switchPersona } = usePersona();

  return (
    <div>
      <p>Current persona: {currentPersona.name}</p>
      <button onClick={() => switchPersona('concept-architect')}>
        Switch to Concept Architect
      </button>
    </div>
  );
}
```

### Connecting to the Editor Sync Service

```jsx
// Inside a component using CodeMirror
import editorSyncService from '../../services/editorSyncService';

// After CodeMirror initialization
useEffect(() => {
  if (editor && conceptCanvasRef.current) {
    editorSyncService.initialize(editor, conceptCanvasRef.current);

    // Highlight specific nodes
    const marker = editorSyncService.highlightNode('node-123');

    return () => {
      marker.clear();
    };
  }
}, [editor]);
```

### Registering with Accessibility Bridge

```jsx
// Inside a component
import accessibilityBridgeService from '../../services/accessibilityBridgeService';

// In useEffect or component lifecycle method
const componentRef = useRef();

useEffect(() => {
  // Register the component
  const unregister = accessibilityBridgeService.register('my-component',
    componentRef, {
      type: 'interactive',
      description: 'My custom component'
    }
  );

  // Register commands
  const unregisterCommand = accessibilityBridgeService.registerCommand(
    'my-component', 'doSomething',
    (args) => {
      // Command implementation
      return { success: true, result: 'Done!' };
    }
  );

  return () => {
    unregister();
    unregisterCommand();
  };
}, []);
