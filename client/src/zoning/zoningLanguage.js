// zoningLanguage.js
// Zoning Language (ZL) parser & Conceptual Neighborhood core types
// This is agentic/internal: not for direct user scripting, but for agent/IDE and future UI tools

/**
 * ConceptNeighborhood type
 */
export class ConceptNeighborhood {
  constructor({ id, label, color, concepts = [], emotionalTone, recentActivity = [], oscillatorAnchor, phaseWindow, relatesTo = [], decayRule, inferredFrom }) {
    this.id = id;
    this.label = label;
    this.color = color;
    this.concepts = concepts; // array of concept IDs/labels
    this.emotionalTone = emotionalTone; // 'friction' | 'flow' | ...
    this.recentActivity = recentActivity; // array of TimelineEvent
    this.oscillatorAnchor = oscillatorAnchor; // string (oscillator id)
    this.phaseWindow = phaseWindow; // [min, max]
    this.relatesTo = relatesTo; // array of neighborhood ids
    this.decayRule = decayRule; // { matchIf, decay }
    this.inferredFrom = inferredFrom; // for agent-autogenerated zones
  }
}

/**
 * ZL Zone DSL parser (minimal, extendable)
 * Supports: zone name { concepts: [...], anchor, color, tone, relates_to, oscillator, phase_window, decay, inferred_from }
 */
export function parseZoningLanguage(zlText) {
  // This is a minimal, line-oriented parser for demo; can be replaced with a PEG/grammar parser later
  const zones = [];
  const zoneRegex = /zone\s+"([^"]+)"\s*{([\s\S]*?)}/g;
  let match;
  while ((match = zoneRegex.exec(zlText))) {
    const [, label, body] = match;
    const zone = { label, concepts: [], relatesTo: [], recentActivity: [] };
    // Extract fields
    body.split(/\n|;/).forEach(line => {
      const l = line.trim();
      if (l.startsWith('concepts:')) {
        zone.concepts = l.match(/\[([^\]]+)\]/)?.[1].split(',').map(s => s.trim().replace(/"/g, '')) || [];
      } else if (l.startsWith('anchor:')) {
        zone.oscillatorAnchor = l.split(':')[1].trim().replace(/"/g, '');
      } else if (l.startsWith('color:')) {
        zone.color = l.split(':')[1].trim().replace(/"/g, '');
      } else if (l.startsWith('tone:')) {
        zone.emotionalTone = l.split(':')[1].trim().replace(/"/g, '');
      } else if (l.startsWith('relates_to:')) {
        zone.relatesTo = l.match(/\[([^\]]+)\]/)?.[1].split(',').map(s => s.trim().replace(/"/g, '')) || [];
      } else if (l.startsWith('oscillator:')) {
        zone.oscillatorAnchor = l.split(':')[1].trim().replace(/"/g, '');
      } else if (l.startsWith('phase_window:')) {
        zone.phaseWindow = l.match(/\[([^\]]+)\]/)?.[1].split(',').map(s => parseFloat(s.trim())) || [];
      } else if (l.startsWith('decay:')) {
        zone.decayRule = { decay: true };
      } else if (l.startsWith('match_if:')) {
        zone.decayRule = zone.decayRule || {};
        zone.decayRule.matchIf = l.replace('match_if:', '').trim();
      } else if (l.startsWith('inferred_from:')) {
        zone.inferredFrom = l.match(/\[([^\]]+)\]/)?.[1].split(',').map(s => s.trim().replace(/"/g, '')) || [];
      }
    });
    zone.id = zone.label.toLowerCase().replace(/\s+/g, '_');
    zones.push(new ConceptNeighborhood(zone));
  }
  return zones;
}

/**
 * NeighborhoodManager: holds all neighborhoods, supports queries
 */
export class NeighborhoodManager {
  constructor() {
    this.neighborhoods = [];
  }
  loadFromZL(zlText) {
    this.neighborhoods = parseZoningLanguage(zlText);
  }
  getNeighborhoodByConcept(concept) {
    return this.neighborhoods.find(n => n.concepts.includes(concept));
  }
  getNeighborhoodById(id) {
    return this.neighborhoods.find(n => n.id === id);
  }
  getNeighborhoodsByOscillator(oscId) {
    return this.neighborhoods.filter(n => n.oscillatorAnchor === oscId);
  }
  all() {
    return this.neighborhoods;
  }
}

// Example ZL snippet (for dev/test)
export const exampleZL = `
zone "Refactor Loop" {
  concepts: ["extractMethod", "duplicateLogic", "namingFatigue"]
  anchor: "utils/DateFormatter.ts"
  color: "orange"
  tone: "friction"
}
zone "Async Hell" {
  concepts: ["fetch", "timeout", "raceCondition"]
  relates_to: ["Refactor Loop", "Test Loop"]
}
zone "Focus Zone" {
  concepts: ["cleanArchitecture", "dataBoundary"]
  oscillator: "deepWorkPattern"
  phase_window: [0.65, 0.85]
}
`;
